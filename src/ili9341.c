/*
 * ili9341.c
 *
 *  Created on: 16. 7. 2019
 *      Author: daymoon
 */

#include "ili9341.h"
#include "stdlib.h"
#include "application.h"
#include "delay.h"
#include "spi.h"
#include "string.h"

static uint16_t ili_width = ILI9341_TFTWIDTH;
static uint16_t ili_height = ILI9341_TFTHEIGHT;

#define CHARHEIGHT		12
#define CHARWIDTH		12
const uint16_t ASCII12x12_Table [] = {
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,	// space
    0x0000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x0000,0x2000,0x0000,0x0000,	// !
    0x0000,0x5000,0x5000,0x5000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,	// "
    0x0000,0x0900,0x0900,0x1200,0x7f00,0x1200,0x7f00,0x1200,0x2400,0x2400,0x0000,0x0000,	// #
    0x1000,0x3800,0x5400,0x5000,0x5000,0x3800,0x1400,0x5400,0x5400,0x3800,0x1000,0x0000,	// $
    0x0000,0x3080,0x4900,0x4900,0x4a00,0x32c0,0x0520,0x0920,0x0920,0x10c0,0x0000,0x0000,	// %
    0x0000,0x0c00,0x1200,0x1200,0x1400,0x1800,0x2500,0x2300,0x2300,0x1d80,0x0000,0x0000,	// &
    0x0000,0x4000,0x4000,0x4000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,	// '
    0x0000,0x0800,0x1000,0x1000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x1000,0x1000,	// (
    0x0000,0x4000,0x2000,0x2000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x2000,0x2000,	// )
    0x0000,0x2000,0x7000,0x2000,0x5000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,	// *
    0x0000,0x0000,0x0000,0x0800,0x0800,0x7f00,0x0800,0x0800,0x0000,0x0000,0x0000,0x0000,	// +
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2000,0x2000,0x4000,	// ,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7000,0x0000,0x0000,0x0000,0x0000,0x0000,	// -
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2000,0x0000,0x0000,	// .
    0x0000,0x1000,0x1000,0x1000,0x2000,0x2000,0x2000,0x2000,0x4000,0x4000,0x0000,0x0000,	// /
    0x0000,0x1000,0x2800,0x4400,0x4400,0x4400,0x4400,0x4400,0x2800,0x1000,0x0000,0x0000,	// 0
    0x0000,0x1000,0x3000,0x5000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x0000,0x0000,	// 1
    0x0000,0x3000,0x4800,0x4400,0x0400,0x0800,0x1000,0x2000,0x4000,0x7c00,0x0000,0x0000,	// 2
    0x0000,0x3000,0x4800,0x0400,0x0800,0x1000,0x0800,0x4400,0x4800,0x3000,0x0000,0x0000,	// 3
    0x0000,0x0800,0x1800,0x1800,0x2800,0x2800,0x4800,0x7c00,0x0800,0x0800,0x0000,0x0000,	// 4
    0x0000,0x3c00,0x2000,0x4000,0x7000,0x4800,0x0400,0x4400,0x4800,0x3000,0x0000,0x0000,	// 5
    0x0000,0x1800,0x2400,0x4000,0x5000,0x6800,0x4400,0x4400,0x2800,0x1000,0x0000,0x0000,	// 6
    0x0000,0x7c00,0x0400,0x0800,0x1000,0x1000,0x1000,0x2000,0x2000,0x2000,0x0000,0x0000,	// 7
    0x0000,0x1000,0x2800,0x4400,0x2800,0x1000,0x2800,0x4400,0x2800,0x1000,0x0000,0x0000,	// 8
    0x0000,0x1000,0x2800,0x4400,0x4400,0x2c00,0x1400,0x0400,0x4800,0x3000,0x0000,0x0000,	// 9
    0x0000,0x0000,0x0000,0x2000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2000,0x0000,0x0000,	// :
    0x0000,0x0000,0x0000,0x2000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2000,0x2000,0x4000,	// ;
    0x0000,0x0000,0x0400,0x0800,0x3000,0x4000,0x3000,0x0800,0x0400,0x0000,0x0000,0x0000,	// <
    0x0000,0x0000,0x0000,0x7c00,0x0000,0x0000,0x7c00,0x0000,0x0000,0x0000,0x0000,0x0000,	// =
    0x0000,0x0000,0x4000,0x2000,0x1800,0x0400,0x1800,0x2000,0x4000,0x0000,0x0000,0x0000,	// >
    0x0000,0x3800,0x6400,0x4400,0x0400,0x0800,0x1000,0x1000,0x0000,0x1000,0x0000,0x0000,	// ?
    0x0000,0x1800,0x2400,0x2400,0x1800,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,	// @ st.C kolecko
    0x0000,0x0800,0x1400,0x1400,0x1400,0x2200,0x3e00,0x2200,0x4100,0x4100,0x0000,0x0000,	// A
    0x0000,0x3c00,0x2200,0x2200,0x2200,0x3c00,0x2200,0x2200,0x2200,0x3c00,0x0000,0x0000,	// B
    0x0000,0x0e00,0x1100,0x2100,0x2000,0x2000,0x2000,0x2100,0x1100,0x0e00,0x0000,0x0000,	// C
    0x0000,0x3c00,0x2200,0x2100,0x2100,0x2100,0x2100,0x2100,0x2200,0x3c00,0x0000,0x0000,	// D
    0x0000,0x3e00,0x2000,0x2000,0x2000,0x3e00,0x2000,0x2000,0x2000,0x3e00,0x0000,0x0000,	// E
    0x0000,0x3e00,0x2000,0x2000,0x2000,0x3c00,0x2000,0x2000,0x2000,0x2000,0x0000,0x0000,	// F
    0x0000,0x0e00,0x1100,0x2100,0x2000,0x2700,0x2100,0x2100,0x1100,0x0e00,0x0000,0x0000,	// G
    0x0000,0x2100,0x2100,0x2100,0x2100,0x3f00,0x2100,0x2100,0x2100,0x2100,0x0000,0x0000,	// H
	0x0000,0x0800,0x0800,0x0800,0x0800,0x0800,0x0800,0x0800,0x0800,0x0800,0x0000,0x0000,	// I
    0x0000,0x0800,0x0800,0x0800,0x0800,0x0800,0x0800,0x4800,0x4800,0x3000,0x0000,0x0000,	// J
    0x0000,0x2200,0x2400,0x2800,0x2800,0x3800,0x2800,0x2400,0x2400,0x2200,0x0000,0x0000,	// K
    0x0000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x3e00,0x0000,0x0000,	// L
    0x0000,0x2080,0x3180,0x3180,0x3180,0x2a80,0x2a80,0x2a80,0x2a80,0x2480,0x0000,0x0000,	// M
    0x0000,0x2100,0x3100,0x3100,0x2900,0x2900,0x2500,0x2300,0x2300,0x2100,0x0000,0x0000,	// N
    0x0000,0x0c00,0x1200,0x2100,0x2100,0x2100,0x2100,0x2100,0x1200,0x0c00,0x0000,0x0000,	// O
    0x0000,0x3c00,0x2200,0x2200,0x2200,0x3c00,0x2000,0x2000,0x2000,0x2000,0x0000,0x0000,	// P
    0x0000,0x0c00,0x1200,0x2100,0x2100,0x2100,0x2100,0x2100,0x1600,0x0d00,0x0100,0x0000,	// Q
    0x0000,0x3e00,0x2100,0x2100,0x2100,0x3e00,0x2400,0x2200,0x2100,0x2080,0x0000,0x0000,	// R
    0x0000,0x1c00,0x2200,0x2200,0x2000,0x1c00,0x0200,0x2200,0x2200,0x1c00,0x0000,0x0000,	// S
    0x0000,0x3e00,0x0800,0x0800,0x0800,0x0800,0x0800,0x0800,0x0800,0x0800,0x0000,0x0000,	// T
    0x0000,0x2100,0x2100,0x2100,0x2100,0x2100,0x2100,0x2100,0x1200,0x0c00,0x0000,0x0000,	// U
    0x0000,0x4100,0x4100,0x2200,0x2200,0x2200,0x1400,0x1400,0x1400,0x0800,0x0000,0x0000,	// V
    0x0000,0x4440,0x4a40,0x2a40,0x2a80,0x2a80,0x2a80,0x2a80,0x2a80,0x1100,0x0000,0x0000,	// W
    0x0000,0x4100,0x2200,0x1400,0x1400,0x0800,0x1400,0x1400,0x2200,0x4100,0x0000,0x0000,	// X
    0x0000,0x4100,0x2200,0x2200,0x1400,0x0800,0x0800,0x0800,0x0800,0x0800,0x0000,0x0000,	// Y
    0x0000,0x7e00,0x0200,0x0400,0x0800,0x1000,0x1000,0x2000,0x4000,0x7e00,0x0000,0x0000,	// Z
    0x0000,0x3000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,	// [
    0x0000,0x4000,0x4000,0x2000,0x2000,0x2000,0x2000,0x2000,0x1000,0x1000,0x0000,0x0000,	// "\"
	0x0000,0x6000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,	// ]
    0x0000,0x1000,0x2800,0x2800,0x2800,0x4400,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,	// ^
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7e00,	// _
    0x0000,0x1000,0x3800,0x7C00,0xFE00,0x1000,0x1000,0xF000,0x0000,0x0000,0x0000,0x0000,	// ` sipka nahoru jako specialni symbol
    0x0000,0x0000,0x0000,0x3800,0x4400,0x0400,0x3c00,0x4400,0x4400,0x3c00,0x0000,0x0000,	// a
    0x0000,0x4000,0x4000,0x5800,0x6400,0x4400,0x4400,0x4400,0x6400,0x5800,0x0000,0x0000,	// b
    0x0000,0x0000,0x0000,0x3000,0x4800,0x4000,0x4000,0x4000,0x4800,0x3000,0x0000,0x0000,	// c
    0x0000,0x0400,0x0400,0x3400,0x4c00,0x4400,0x4400,0x4400,0x4c00,0x3400,0x0000,0x0000,	// d
    0x0000,0x0000,0x0000,0x3800,0x4400,0x4400,0x7c00,0x4000,0x4400,0x3800,0x0000,0x0000,	// e
    0x0000,0x6000,0x4000,0xe000,0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,0x0000,0x0000,	// f
    0x0000,0x0000,0x0000,0x3400,0x4c00,0x4400,0x4400,0x4400,0x4c00,0x3400,0x0400,0x4400,	// g
    0x0000,0x4000,0x4000,0x5800,0x6400,0x4400,0x4400,0x4400,0x4400,0x4400,0x0000,0x0000,	// h
    0x0000,0x4000,0x0000,0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,0x0000,0x0000,	// i
    0x0000,0x4000,0x0000,0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,	// j
    0x0000,0x4000,0x4000,0x4800,0x5000,0x6000,0x5000,0x5000,0x4800,0x4800,0x0000,0x0000,	// k
    0x0000,0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,0x0000,0x0000,	// l
    0x0000,0x0000,0x0000,0x5200,0x6d00,0x4900,0x4900,0x4900,0x4900,0x4900,0x0000,0x0000,	// m
    0x0000,0x0000,0x0000,0x5800,0x6400,0x4400,0x4400,0x4400,0x4400,0x4400,0x0000,0x0000,	// n
    0x0000,0x0000,0x0000,0x3800,0x4400,0x4400,0x4400,0x4400,0x4400,0x3800,0x0000,0x0000,	// o
    0x0000,0x0000,0x0000,0x5800,0x6400,0x4400,0x4400,0x4400,0x6400,0x5800,0x4000,0x4000,	// p
    0x0000,0x0000,0x0000,0x3400,0x4c00,0x4400,0x4400,0x4400,0x4c00,0x3400,0x0400,0x0400,	// q
    0x0000,0x0000,0x0000,0x5000,0x6000,0x4000,0x4000,0x4000,0x4000,0x4000,0x0000,0x0000,	// r
    0x0000,0x0000,0x0000,0x3000,0x4800,0x4000,0x3000,0x0800,0x4800,0x3000,0x0000,0x0000,	// s
    0x0000,0x4000,0x4000,0xe000,0x4000,0x4000,0x4000,0x4000,0x4000,0x6000,0x0000,0x0000,	// t
    0x0000,0x0000,0x0000,0x4400,0x4400,0x4400,0x4400,0x4400,0x4c00,0x3400,0x0000,0x0000,	// u
    0x0000,0x0000,0x0000,0x4400,0x4400,0x2800,0x2800,0x2800,0x2800,0x1000,0x0000,0x0000,	// v
    0x0000,0x0000,0x0000,0x4900,0x4900,0x5500,0x5500,0x5500,0x5500,0x2200,0x0000,0x0000,	// w
    0x0000,0x0000,0x0000,0x4400,0x2800,0x2800,0x1000,0x2800,0x2800,0x4400,0x0000,0x0000,	// x
    0x0000,0x0000,0x0000,0x4400,0x4400,0x2800,0x2800,0x2800,0x1000,0x1000,0x1000,0x1000,	// y
    0x0000,0x0000,0x0000,0x7800,0x0800,0x1000,0x2000,0x2000,0x4000,0x7800,0x0000,0x0000,	// z
    0x0000,0x1000,0x2000,0x2000,0x2000,0x2000,0x4000,0x2000,0x2000,0x2000,0x2000,0x2000,	// {
    0x0000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,	// |
    0x0000,0x4000,0x2000,0x2000,0x2000,0x2000,0x1000,0x2000,0x2000,0x2000,0x2000,0x2000,	// }
    0x0000,0x1000,0x1800,0x1C00,0xFE00,0x1C00,0x1800,0x1000,0x0000,0x0000,0x0000,0x0000,	// ~ - sipka doprava jako specialni symbol
    0x0000,0x0000,0x7000,0x5000,0x5000,0x5000,0x5000,0x5000,0x5000,0x7000,0x0000,0x0000};	//

#define INV           	80
#define NOINV         	0

#define BACKGROUND    	ILI9341_BLACK
#define FOREGROUND		ILI9341_WHITE


void lcd_config(void)
{
	// HW reset
	//RST_active();
	//delay_ms(100);
	//RST_deactive();

	// SW reset
	send_instruction(ILI9341_SWRESET);
	delay_ms(100);

	// (Display off)
	//send_instruction(0x28);
	// Issue a series of initialization commands from the Adafruit library for a simple 'known good' test

	send_instruction(0xEF);
	send_data(0x03);
	send_data(0x80);
	send_data(0x02);

	send_instruction(0xCF);
	send_data(0x00);
	send_data(0xC1);
	send_data(0x30);

	send_instruction(0xED);
	send_data(0x64);
	send_data(0x03);
	send_data(0x12);
	send_data(0x81);

	send_instruction(0xE8);
	send_data(0x85);
	send_data(0x00);
	send_data(0x78);

	send_instruction(0xCB);
	send_data(0x39);
	send_data(0x2C);
	send_data(0x00);
	send_data(0x34);
	send_data(0x02);

	send_instruction(0xF7);
	send_data(0x20);

	send_instruction(0xEA);
	send_data(0x00);
	send_data(0x00);

	// PWCTR1
	send_instruction(0xC0);
	send_data(0x23);

	// PWCTR2
	send_instruction(0xC1);
	send_data(0x10);

	// VMCTR1
	send_instruction(0xC5);
	send_data(0x3E);
	send_data(0x28);

	// VMCTR2
	send_instruction(0xC7);
	send_data(0x86);

	// MADCTL
	send_instruction(0x36);
	send_data(0x48);

	// VSCRSADD
	send_instruction(0x37);
	send_data(0x00);

	// PIXFMT
	send_instruction(0x3A);
	send_data(0x55);

	// FRMCTR1
	send_instruction(0xB1);
	send_data(0x00);
	send_data(0x18);

	// DFUNCTR
	send_instruction(0xB6);
	send_data(0x08);
	send_data(0x82);
	send_data(0x27);

	send_instruction(0xF2);
	send_data(0x00);

	// GAMMASET
	send_instruction(0x26);
	send_data(0x01);

	// (Actual gamma settings)
	send_instruction(0xE0);
	send_data(0x0F);
	send_data(0x31);
	send_data(0x2B);
	send_data(0x0C);
	send_data(0x0E);
	send_data(0x08);
	send_data(0x4E);
	send_data(0xF1);
	send_data(0x37);
	send_data(0x07);
	send_data(0x10);
	send_data(0x03);
	send_data(0x0E);
	send_data(0x09);
	send_data(0x00);

	send_instruction(0xE1);
	send_data(0x00);
	send_data(0x0E);
	send_data(0x14);
	send_data(0x03);
	send_data(0x11);
	send_data(0x07);
	send_data(0x31);
	send_data(0xC1);
	send_data(0x48);
	send_data(0x08);
	send_data(0x0F);
	send_data(0x0C);
	send_data(0x31);
	send_data(0x36);
	send_data(0x0F);

	// Exit sleep mode.
	send_instruction(0x11);
	delay_ms(150);

	// Display on.
	send_instruction(0x29);
	delay_ms(150);

	// 'Normal' display mode.
	send_instruction(0x13);

	// test cteni ID
	/*
	volatile uint32_t data;
	//send_instruction(0x04);
	data = 0;
	CS_low();
	DC_instruction();
	SPI_Write8(0x04);
	DC_data();
	data += (SPI_Read8() << 24);
	data += (SPI_Read8() << 16);
	data += (SPI_Read8() << 8);
	data += (SPI_Read8());
	CS_high();
	*/

	ili_set_rotation(3);
	//ili_display_clear(ILI9341_BLACK);
	ili_display_clear(ILI9341_BLUE);
	ili_draw_rectangle(10, 10, 310, 230, ILI9341_RED);
}

void ili_display_clear(uint16_t color)
{
	// display clear
	// Set column range.
	send_instruction(ILI9341_CASET);
	send_data16(0x0000);					// start column
	send_data16((uint16_t)(319));			// end column
	// Set row range.
	send_instruction(ILI9341_PASET);
	send_data16(0x0000);					// start line
	send_data16((uint16_t)(239));			// end line

	// Set 'write to RAM'
	send_instruction(ILI9341_RAMWR);

	// Write 320 * 240 pixels
	uint32_t i;
	CS_low();
	DC_data(); 											// DC = H
	for (i = 0; i < (320*240); ++i)
	{
		// Write a 16-bit color
		SPI_Write16(color);								//send_data16(color);
	}
	CS_high();
}

void ili_camera_init(void)
{
	// Set column range.
	send_instruction(ILI9341_CASET);
	send_data16(0x0000);					// start column
	send_data16((uint16_t)(319));			// end column
	// Set row range.
	send_instruction(ILI9341_PASET);
	send_data16(0x0000);					// start line
	send_data16((uint16_t)(239));			// end line

	// Set 'write to RAM'
	send_instruction(ILI9341_RAMWR);

	// Ready to Write 320 * 240 pixels
	uint32_t i;
	CS_low();
	DC_data(); 								// DC = H
}


void ili_set_rotation(uint8_t m)
{
    uint8_t rotation = m % 4; // can't be higher than 3
    switch (rotation) {
        case 0:
            m = (MADCTL_MX | MADCTL_BGR);
            ili_width  = ILI9341_TFTWIDTH;
            ili_height = ILI9341_TFTHEIGHT;
            break;
        case 1:
            m = (MADCTL_MV | MADCTL_BGR);
            ili_width  = ILI9341_TFTHEIGHT;
            ili_height = ILI9341_TFTWIDTH;
            break;
        case 2:
            m = (MADCTL_MY | MADCTL_BGR);
            ili_width  = ILI9341_TFTWIDTH;
            ili_height = ILI9341_TFTHEIGHT;
            break;
        case 3:
            m = (MADCTL_MX | MADCTL_MY | MADCTL_MV | MADCTL_BGR);
            ili_width  = ILI9341_TFTHEIGHT;
            ili_height = ILI9341_TFTWIDTH;
            break;
    }

    send_instruction(ILI9341_MADCTL);
    send_data(m);
}

void ili_set_addr_window(uint16_t x1, uint16_t y1, uint16_t w, uint16_t h)
{
    uint16_t x2 = (x1 + w - 1);
    uint16_t y2 = (y1 + h - 1);

    send_instruction(ILI9341_CASET); // Column address set
    send_data16(x1);
    send_data16(x2);
    send_instruction(ILI9341_PASET); // Row address set
    send_data16(y1);
    send_data16(y2);
    send_instruction(ILI9341_RAMWR); // Write to RAM
}

void ili_draw_pixel(uint16_t x, uint16_t y, uint16_t color)
{
	ili_set_addr_window(x, y, 1, 1);
	send_data16(color);
}
void ili_draw_line(uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color)
{
	int32_t yLonger = 0;
	int32_t incrementVal, endVal;
	int32_t shortLen = y2-y1;
	int32_t longLen = x2-x1;

	if(abs(shortLen) > abs(longLen))
	{
		int32_t swap = shortLen;
		shortLen = longLen;
		longLen = swap;
		yLonger = 1;
	}
	endVal = longLen;

	if(longLen < 0)
	{
		incrementVal =- 1;
		longLen =- longLen;
		endVal--;
	}
	else
	{
		incrementVal = 1;
		endVal++;
	}

	volatile int32_t decInc;

	if(longLen == 0)
	{
		decInc = 0;
	}
	else
	{
		decInc = (shortLen << 16);
		decInc /= longLen;
	}

	volatile int32_t j = 0, i = 0;

	if(yLonger)
	{
		for(i = 0;i != endVal;i += incrementVal)
		{
			ili_draw_pixel(x1 + (j >> 16), y1 + i, color);
			j += decInc;
		}
	}
	else
	{
		for(i = 0;i != endVal;i += incrementVal)
		{
			ili_draw_pixel(x1 + i, y1 + (j >> 16), color);
			j += decInc;
		}
	}
}
void ili_draw_full_rectangle(uint16_t x, uint16_t y, uint8_t sizex, uint16_t sizey, uint16_t color)
{
	uint16_t pomy;

	for (uint16_t posy = 0; posy < sizey; posy++)
	{// kreslime postupne linky v ose y
		pomy = y+posy;
		for (uint16_t posx = 0; posx < sizex; posx++)
		{// kreslime linku v sirce obdelniku
			ili_draw_pixel(x+posx, pomy, color);
		}
	}
}
void ili_draw_rectangle(uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color)
{
  ili_draw_line(x1, y1, x2, y1, color);
  ili_draw_line(x2, y1, x2, y2, color);
  ili_draw_line(x2, y2, x1, y2, color);
  ili_draw_line(x1, y2, x1, y1, color);
}

void ili_print_char(uint8_t character, uint8_t xpos, uint16_t ypos, uint16_t color, uint8_t inv)
{
  uint8_t line;
  uint16_t input;
  uint8_t bitpos;
  uint8_t xposlimit;

  for (line = 0; line < CHARHEIGHT; line++)
  {
	  ili_set_addr_window(xpos, ypos+line, CHARWIDTH, 1);	// st7789v_set_cursor(xpos,ypos+line);        // novy mikroradek pro vykresleni znaku
	  xposlimit = xpos;

	  input = ASCII12x12_Table[CHARHEIGHT*(character-' ')+line];
	  //send_instruction(ILI9341_RAMWR);           // zapis pixelu
	  CS_low();
	  DC_data(); // DC = H

	  for (bitpos = 0; bitpos < CHARWIDTH; bitpos++)	// bylo 8 misto CHARWIDTH
	  {// pro kazdy bit zleva doprava
		  if (xposlimit++ < ILI9341_TFTWIDTH)
		  {
			  if (input & (0x8000 >> bitpos))
			  {
				  // bit je jednicka
				  if (inv == NOINV)
				  {
					  // primy rezim
					  send_data16(color);
				  }
				  else
				  {
					  // inverzni rezim
					  send_data16(BACKGROUND);
				  }
			  }
			  else
			  {
				  // bit je nula
				  send_data16(BACKGROUND);
			  }
		  }
	  }
	  CS_high();
  }
}

void ili_text_print(uint8_t x, uint16_t y, uint8_t *text, uint16_t color, uint8_t mode, uint16_t maxwidth)
{
	volatile uint8_t i, length;

	// pro celou delku retezce nebo maximalni sirku okna vypis text po znacich
	if (CHARWIDTH*strlen((const char*)text) > maxwidth)
	{
		length = maxwidth / CHARWIDTH;
	}
	else
	{
		length = strlen((const char*)text);
	}
	for (i = 0; i < length; i++)
	{
		if (x+i*CHARWIDTH < ILI9341_TFTWIDTH)
		{
			ili_print_char(text[i], x+i*CHARWIDTH, y, color, mode);
		}
	}
}

void ili_draw_circle(uint16_t x, uint16_t y, uint16_t r, uint16_t color)
{
  int32_t D;       /* Decision Variable */
  uint32_t CurX;   /* Current X Value */
  uint32_t CurY;   /* Current Y Value */

  D = 3 - (r << 1);
  CurX = 0;
  CurY = r;

  while (CurX <= CurY)
  {
    if (((x+CurX) < 240) && ((y+CurY) < 320))
      ili_draw_pixel(x+CurX, y+CurY, color);
    if (((x+CurX) < 240) && ((int32_t)(y-CurY) >= 0))
    	ili_draw_pixel(x+CurX, y-CurY, color);
    if (((int32_t)(x-CurX) >= 0) && ((int32_t)(y+CurY) < 320))
    	ili_draw_pixel(x-CurX, y+CurY, color);
    if (((int32_t)(x-CurX) >= 0) && ((int32_t)(y-CurY) >= 0))
    	ili_draw_pixel(x-CurX, y-CurY, color);
    if (((x+CurY) < 240) && ((y+CurX) < 320))
    	ili_draw_pixel(x+CurY, y+CurX, color);
    if (((x+CurY) < 240) && ((int32_t)(y-CurX) >= 0))
    	ili_draw_pixel(x+CurY, y-CurX, color);
    if (((int32_t)(x-CurY) >= 0) && ((int32_t)(y+CurX) < 320))
    	ili_draw_pixel(x-CurY, y+CurX, color);
    if (((int32_t)(x-CurY) >= 0) && ((int32_t)(y-CurX) >= 0))
    	ili_draw_pixel(x-CurY, y-CurX, color);

    if (D < 0)
    {
      D += (CurX << 2) + 6;
    }
    else
    {
      D += ((CurX - CurY) << 2) + 10;
      CurY--;
    }
    CurX++;
  }
}

void ili_draw_full_circle(uint16_t x, uint16_t y, uint16_t r, uint16_t color)
{
  int32_t D;       /* Decision Variable */
  uint32_t CurX;   /* Current X Value */
  uint32_t CurY;   /* Current Y Value */

  D = 3 - (r << 1);
  CurX = 0;
  CurY = r;

  while (CurX <= CurY)
  {
    if(CurY > 0)
    {
    	ili_draw_line(x-CurX, y+CurY, x-CurX, y-CurY, color);
    	ili_draw_line(x+CurX, y+CurY, x+CurX, y-CurY, color);
    }

    if(CurX > 0)
    {
    	ili_draw_line(x-CurY, y+CurX, x-CurY, y-CurX, color);
    	ili_draw_line(x+CurY, y+CurX, x+CurY, y-CurX, color);
    }

    if (D < 0)
    {
      D += (CurX << 2) + 6;
    }
    else
    {
      D += ((CurX - CurY) << 2) + 10;
      CurY--;
    }
    CurX++;
  }
}

void RST_active(void)
{
  //GPIO_ResetBits(LCD_RST_PORT, LCD_RST_PIN);			// RST low
}

void RST_deactive(void)
{
  //GPIO_SetBits(LCD_RST_PORT, LCD_RST_PIN);				// RST high
}

void CS_low(void)
{
	GPIO_ResetBits(LCD_CS_PORT, LCD_CS_PIN);			// CS low
}

void CS_high(void)
{
	while ((LCD_SPI->SR & SPI_SR_BSY)) {};
	GPIO_SetBits(LCD_CS_PORT, LCD_CS_PIN);				// CS high
}

void DC_instruction(void)
{
	GPIO_ResetBits(LCD_DC_PORT, LCD_DC_PIN);			// DC low
}

void DC_data(void)
{
	GPIO_SetBits(LCD_DC_PORT, LCD_DC_PIN);				// DC high
}

void send_instruction(uint8_t byte)
{
	CS_low();
	DC_instruction(); 									// DC = L
	SPI_Write8(byte);
	CS_high();
}

void send_data(uint8_t byte)
{
  CS_low();
  DC_data(); 											// DC = H
  SPI_Write8(byte);
  CS_high();
}

void send_data16(uint16_t data)
{
  CS_low();
  DC_data(); 											// DC = H
  SPI_Write16(data);
  CS_high();
}

